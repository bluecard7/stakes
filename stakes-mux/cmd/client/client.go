package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"stakes/internal/config"
	"strings"

	"github.com/dgrijalva/jwt-go"
)

func main() {
	config.ConfigureApp()

	// would be generated by auth server
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"email": "my@email.com",
		// "exp", iat or nbf for time exp claims for Valid()
		// -> lack of which means valid by default
	})
	tokenStr, err := token.SignedString([]byte("secret"))
	fmt.Println("[INFO]", tokenStr, err)

	client := http.Client{}
	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("> ")
		text, _ := reader.ReadString('\n')
		cmd := strings.Trim(text, "\n")
		var (
			req *http.Request
			res *http.Response
			err error
		)
		switch cmd {
		case "get":
			req, err = http.NewRequest("GET", "http://localhost:8000/clock?from=2020-01-01&to=2020-12-30", nil)
		case "post":
			req, err = http.NewRequest("POST", "http://localhost:8000/clock", nil)
		case "exit":
			return
		}
		if err != nil {
			fmt.Println("[ERROR]", err)
		}
		req.Header.Set("Authorization", tokenStr)
		res, err = client.Do(req)
		if err != nil {
			fmt.Println(err)
			continue
		}
		body, _ := ioutil.ReadAll(res.Body)
		res.Body.Close()
		if err == nil {
			fmt.Println("[RESPONSE]", string(body))
		} else {
			fmt.Println("[ERROR]", err)
		}

	}
}
